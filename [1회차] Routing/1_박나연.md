# 1. Defining Routes

Next js는 라우터를 기반으로 하는 파일 시스템을 사용한다. 경로들을 정의하는데 익숙한 폴더들에 있는 라우터들이다.
각 폴더는 url 세그먼트 만드는 라우터 segment를 의미한다. 중첩된 라우트를 만들려면, 너는 각 폴더 안에 중첩된 폴더를 만들면 된다.  
폴더 구조 app / dashboard / settings -> 경로 acme.com/dashboard/settings.

특별한 pages.js파일은 public하게 접근가능한 라우트 세그먼트들을 만드는데 사용한다. = private 하지 않다.

예를 들어 /dashboard/analytics URL 경로는 public하게 접근할 수 없다. 왜냐하면 해당하는 page.js파일이 폴더에 없기 때문이다.
이 폴더는 컴포넌트들, 스타일시트, 이미지, 다른 관련 파일들도 저장한다.
.js, .jsx 또는 .tsx 파일 확장자들이 특정 파일에 사용될 수 있다.

UI 만들기
특정 파일 컨벤션들은 각 라우트 시크먼트에 대한 UI들을 만드는데 익숙하다. 가장 기본적인 파일 컨벤션은 각 경로에서 UI를 보여주는 페이지 파일, 여러 라우트들 사이에서 공유되는 UI를 보여주는 레이아웃 파일들이 있다.

예를들어 첫번째 페이지를 만들고자 할때, page.js파일을 app 폴더에 추가하고 React컴포넌트를 내보내라.

```
export default function Page() {
  return <h1>Hello, Next.js!</h1>
}
```

# 2. Pages and Layouts

Next.js 13에서 App Router는 새로운 파일 컨벤션들을 소개한다. 쉽게 페이지를 만들거나, 레이아웃과 템플릿들을 공유할 수 있는 템플릿을 말이다.
이 페이지는 어떻게 하면 Next.js 어플리케이션에 이 특정 파일들을 사용할 수 있는 방법을 알려줄 것이다.

## Pages

이 페이지는 UI이다. 하나의 경로마다 대응하는 UI이다. 너는 page.js파일로 부터 컴포넌트들을 내보내기 함으로써 페이지들을 정의할 수 있다. 경로와 page.js를 정의하기 위하여 중첩된 폴더들을 사용해라 public 공적으로 접근 가능한 경로를 만들기 위해서 말이다.

첫 페이지를 만들어라 page.js 파일을 app 폴더에 추가하면 된다.

![image.png](https://nextjs.org/_next/image?url=%2Fdocs%2Flight%2Fpage-special-file.png&w=1920&q=75&dpl=dpl_33QVxNnXdHM9N19sRcdZhDZZsXEw)

해당 폴더 구조는 /dashboard라는 경로를 정의하게 된다.

```
export default function Page() {
  return <h1>Hello, Home page!</h1>
}
```

app/page.tsx is the UI for the '/' URL

```
export default function Page() {
  return <h1>Hello, Dashboard Page!</h1>
}
app/dashboard/page.tsx is the UI for the '/dashboard' URL
```

### ✨ 알면 좋은 것들

> - 하나의 페이지는 항상 라우트의 서브 트리의 잎에 해당한다.
> - .js, .jsx 또는 .tsx파일 확장자들은 페이지들이 된다.
> - page.js파일은 공적으로 접근 가능한 경로 세그먼트를 만들기 위해 있는 파일이다.
> - 페이지들은 기본적으로 서버 컴포넌트들이지만 클라이언트 컴포넌트로 설정할 수도 있다.
> - 페이지들은 데이터를 fetch할 수 있다. 더 많은 정보는 데이터 패칭 섹션에서 살펴보자

## Layouts

layout은 여러 페이지들 사이에서 공유되는 UI이다. 네비게이션에서, 레이아웃들은 상태를 보존하고 서로 상호작용하며, 리렌더링 하지 않는다. 그리고 레이아웃은 중첩될 수 있다.

레이아웃을 정의할 수 있다. layout.js 파일에서 리액트 컴포넌트를 default 내보내기함으로써 말이다.
이 컴포넌트는 children prop을 받을 수 있으며 렌더링 동안에 child 페이지나 layout을 채워지게 될 것이다.

```
export default function DashboardLayout({
  children, // will be a page or nested layout
}: {
  children: React.ReactNode
}) {
  return (
    <section>
      {/* Include shared UI here e.g. a header or sidebar */}
      <nav></nav>

      {children}
    </section>
  )
}

app/dashboard/layout.tsx
```

### ✨ 알면 좋은 것들

> - 가장 상위의 layout은 Root layout이라고 부른다. Root layout은 application안에 모든 페이지들 간에서 공유되어야 한다.
>   Root layout들은 html, body 테그를 반드시 포함해야 한다.
> - 어떤 라우트 세그먼트들이라도 선택적으로 그 라우트만 가지는 layout을 정의할 수 있다. 이 layout들은 그 라우트 세그먼트 내에 해당하는 모든 페이지들 사이에서 공유될 수 있다.
> - 한 라우트 안에 레이아웃들은 기본적으로 중첩된다. 각 부모 레이아웃들은 리액트 children prop을 사용하여 자식 레이아웃을 그 아래에 감싼다.
> - 라우트 그룹을 사용하여 공유 레이아웃에 들어가고 나오는 특정 경로 세그먼트를 선택할 수 있다.
> - 페이지들은 기본적으로 서버 컴포넌트들이지만 클라이언트 컴포넌트로 설정할 수도 있다.
> - 페이지들은 데이터를 fetch할 수 있다. 더 많은 정보는 데이터 패칭 섹션에서 살펴보자
> - 부모 레이아웃과 해당 부모의 자식들의 레이아웃 사이로 데이터가 지나갈 수 없다. 그러나 너가 같은 데이터를 하나의 라우트에서 여러번 fetch할 수 있다. 그리고 react는 성능에 영향을 주지 않고 자동으로 요청을 중복 제거한다.
> - 레이아웃들은 하위에 있는 경로 세그먼트에 접근할 수 없다. 오든 라우트 세그먼트에 접근하기 위해, 클라이언트 컴포넌트에서 useSelectedLayoutSegement나 useSelectedlayoutSegements를 사용할 수 있다.
> - .js, .jsx나 .tsx 파일 확장자들을 layouts을 위해 사용할 수 있다.
> - layout.js와 page.js파일은 같은 폴더에서 정의될 수 있다. layout은 페이지를 감쌀 수 있다.

## Root Layout

Root layout은 app 폴더의 최상위에서 정의된다. 그리고 모든 라우트들에 적용된다. 이 레이아웃은 서버로부터 반환된 최초의 HTML을 수정하는 것을 가능하게 해준다.

```
export default function RootLayout({
 children,
}: {
 children: React.ReactNode
}) {
 return (
   <html lang="en">
     <body>{children}</body>
   </html>
 )
}
```

### ✨ 알면 좋은 것들

> - app 폴더는 root layout을 포함해야만 한다.
> - root layout은 <html> tag와 <body> tag를 정의해야만 한다. Next.js가 자동적으로 이 두개의 태그를 생성하지 않기 때문이다.
> - <head> HTML 요소들을 관리하는 built-in SEO support를 사용할 수 있다. 예를 들어 <title> 요소가 있다.
> - 다양한 root layouts를 만들기 위해서 route groups를 사용할 수 있다.
> - root layout는 기본적으로 서버 컴포넌트이지만 클라이언트 컴포넌트로 설정할 수 있다.

pages폴더로부터 이동하기 : root layout은 `\_app.js`와 `\_document.js`를 대신할 수 있다.

## Nesting Layouts

layout은 폴더 안에 정의한다. (예로, app/dashboard/layout.js) 특정 경로 세그먼트를 적용하고, 그 segment들이 작동할 때 렌더하는 폴더이다. 기본값으로, 이 파일 계급 안에 layout은 중첩되며 이것은 부모 layout이 children prop을 통해 자식 layout을 감싸는 것을 의미한다.

```
export default function DashboardLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return <section>{children}</section>
}
```

### ✨ 알면 좋은 것들

> - root layout만이 <html>과 <body>태그를 가진다.
> - 만약 두개의 layout을 결합할 경우, root layout은 dashboard/layout.js 레이아웃을 감쌀 것이다. app/dashboard/\* 안에 경로 세그먼트들을 감싸면서
>   공유된 layout 안과 밖에서 특정 경로 세그먼트를 선택하기 위해 Route Groups를 사용할 수 있다.

## Templates

Templates는 Templates들은 각 자식 layout이나 page를 감싼다는 점이 layouts과 비슷하다.
여러 경로들 사이에서 지속되고 상태를 유지하는 layouts와 다르게 templates는 탐색 시 각 자식에 대한 새로운 인스턴스를 생성한다.
즉, 사용자가 템플릿을 공유하는 경로 사이를 탐색할 때, 컴포넌트의 새로운 인스턴스가 마운트 되고, DOM요소들은 재생성되고, 상태는 유지되지 않으며, 효과가 다시 동기화된다.

이러한 특정 동작이 필요한 경우도 있을 수 있으며, 레이아웃보다는 템플릿이 더 적합한 옵션이다.
에를들어 :

- useEffect와 useState에 의존하는 기능들
- 기존 프레임워크 동작을 변경할 때, 예를들어 layout 안에 Suspense Boundaries는 처음에 fallback만 보여준다. layout은 로드되고 페이지가 바뀌지 않을 때 말이죠, 템플릿을 위해, fallback은 각 navigation에 표시된다.

template은 정의 될 수 있다. template.js파일로부터 React 컴포넌트가 default 내보내기 됨으로써 정의 된다. 이 컴포넌트는 children prop을 사용해야 한다.

```
export default function Template({ children }: { children: React.ReactNode }) {
  return <div>{children}</div>
}
```

중첩이라는 용어에서, template.js는 layout과 layout의 자식들 사이에서 렌더된다.
간단한 예시 :

```
<Layout>
  {/* Note that the template is given a unique key. */}
  <Template key={routeParam}>{children}</Template>
</Layout>
```

## Modifying <head>

app 폴더에서, <head> HTML 요소들을 수정할 수 있다. title태그와 meta태그 같은 요소들이 있다. built-in SEO support를 사용해서!
Metadata는 layout.js나 page.js 파일에서 metadata 객체나 generateMetadata 함수를 내보냄으로써 정의 될 수 있다

```
app/page.tsx
import { Metadata } from 'next'

export const metadata: Metadata = {
  title: 'Next.js',
}

export default function Page() {
  return '...'
}
```

### ✨ 알면 좋은 점

> <head>태그들(<title>과 <meta>태그 같은)을 root layouts로 손수 추가하지 않아도 된다. 대신에, 스트리밍 및 <head> 요소를 중복 제거와 같은 고급 요구 사항을 자동으로 처리하는 Metadata API를 사용해야 한다.

# Linking and Navigating

Next js에서 경로들을 탐색하는 2가지 방법

- <Link> 컴포넌트 사용
- useRouter 훅 사용

이 페이지는 <Link>, useRouter를 사용하는 방법 알아볼 것이고, 어떻게 탐색이 작동하는지에 깊게 들어가볼 것이다.

## <Link> 컴포넌트

<Link> 컴포넌트는 HTML <a> 태그를 확장하여 만들어진 컴포넌트이다. prefetching과 클라이언트 사이드 경로 탐색을 제공한다.
Next js에서 경로탐색을 하는 주된 방법이다.

next/link로부터 import하고 a href prop을 컴포넌트에 전달하여 사용할 수 있다.

```
import Link from 'next/link'

export default function Page() {
  return <Link href="/dashboard">Dashboard</Link>
}
```

<Link>태그에 전달해줄 수 있는 다른 선택적 props들도 있다.

### 예시

- 동적 세그먼트들을 연결하다
  동적 세그먼트들을 연결할 때, template 리터럴과 목록을 사용하여 링크 목록을 생성할 수 있다.

예를들어, 블로그 게시물 목록을 생성하는 방법 :

```
import Link from 'next/link'

export default function PostList({ posts }) {
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>
          <Link href={`/blog/${post.slug}`}>{post.title}</Link>
        </li>
      ))}
    </ul>
  )
}
```

- 활성 링크들 확인하기
  usePathname을 사용하여 링크가 활성 상태인지 확인할 수 있다. 예를들어, 활성 링크에 클래스를 추가하기 위해서, 현재경로 이름이 링크의 href와 일치하는지를 체크할 수 있다.

```
app/components/link.tsx
import { usePathname } from 'next/navigation'
import Link from 'next/link'

export function Links() {
  const pathname = usePathname()

  return (
    <nav>
      <ul>
        <li>
          <Link className={`link ${pathname === '/' ? 'active' : ''}`} href="/">
            Home
          </Link>
        </li>
        <li>
          <Link
            className={`link ${pathname === '/about' ? 'active' : ''}`}
            href="/about"
          >
            About
          </Link>
        </li>
      </ul>
    </nav>
  )
}
```

- id로 스크롤하기
  Next.js App Router의 기본 동작은 새 경로의 맨 위로 스크롤하거나 앞뒤로 탐색할 수 있도록 스크롤 위치를 유지하는 것이다.  
  탐색 시 특정 ID로 스크롤하려면 URL에 # 해시 링크를 추가하거나 href prop에 해시 링크를 전달하면 됩니다. 이는 <Link>가 <a> 요소로 렌더링하기 때문에 가능하다.

```
<Link href="/dashboard#settings">Settings</Link>

// Output
<a href="/dashboard#settings">Settings</a>
```

- 스크롤 복원 비활성화하기
  Next.js App Router의 기본 동작은 새 경로의 맨 위로 스크롤하거나 앞뒤로 탐색할 수 있도록 스크롤 위치를 유지하는 것이다. 이 동작을 사용하지 않으려면 scroll={false}을(를) <Link> 컴포넌트로 전달하거나, scroll: false를 router.push() 또는 router.replace에 전달하여 사용할 수 있다.

```
// next/link
<Link href="/dashboard" scroll={false}>
  Dashboard
</Link>
```

```
// useRouter
import { useRouter } from 'next/navigation'

const router = useRouter()

router.push('/dashboard', { scroll: false })
```

## useRouter() hook

userRouter 후크를 사용하면 프로그래밍 방식으로 경로를 변경할 수 있다.  
이 hook는 클라이언트 컴포넌트들 내에서만 사용할 수 있으며 다음/내비게이션에서 가져온다.

```
'use client'

import { useRouter } from 'next/navigation'

export default function Page() {
  const router = useRouter()

  return (
    <button type="button" onClick={() => router.push('/dashboard')}>
      Dashboard
    </button>
  )
}
```

> 💡추천 : <useRouter>를 사용하기 위한 특정 요구사항이 없는 한, 경로 탐색을 위해서 <Link> 컴포넌트를 사용해라

## 어떻게 Routing과 Navigation이 작동하는걸까?

App 라우터는 라우팅과 탐색을 위해 하이브리드 접근 방식을 사용한다. 서버에서는 application코드가 경로 세그먼트에 의해 자동으로 코드 분활된다. 그리고 클라이언트에서는 Next.js가 경로 세그먼트를 prefetch하고 cache한다. 즉, 사용자가 새 경로로 탐색할 때, 브라우저는 페이지를 다시 로드하지 않고 경로 세그먼트만 변경하여 탐색 경험과 성능을 개선한다.

### 1. Prefetching

Prefetching은 사용자가 경로를 방문하기 전에 백그라운드에서 경로를 미리 로드하는 방법이다.

Next.js에서 경로를 prefetching하는 방법은 2가지이다.  
<링크> 컴포넌트: Routes는 사용자의 뷰포트에 경로가 표시됨에 따라 자동으로 프리페칭됩니다. 프리페칭은 페이지가 처음 로드될 때 또는 스크롤을 통해 볼 수 있을 때 발생한다.  
router.prefetch(): userRouter hook을 사용하여 경로를 프로그래밍 방식으로 prefetch할 수 있다.

<Link>의 prefetching 동작은 정적 경로와 동적 경로에 따라 다르다:  
- 정적 경로: prefetch 기본값은 true. 전체 경로가 prefetch되고 캐시된다.  
- 동적 경로: 기본값을 자동으로 prefetch한다. 첫 번째 loading.js 파일이 30초 동안 prefetch되고 캐시될 때까지 공유된 레이아웃만 다운된다. 이를 통해 전체 동적 경로를 fetch하는 비용을 줄일 수 있으며, 사용자에게 더 나은 시각적 피드백을 위해 즉각적인 로딩 상태를 보여줄 수 있다.  
prefetch prop을 false로 설정하여 prefetch를 비활성화할 수 있습니다.

### ✨ 알면 좋은 점:

> prefetching은 개발 중에는 활성화되지 않고, 생산 중에만 활성화된다.

### 2. Caching

Next.js는 Router Cache라는 in-memory client-side cache를 가지고 있습니다. 사용자가 app을 탐색할 때, 미리 fetch된 경로 세그먼트와 방문한 경로의 React Server Component Payload가 캐시에 저장된다.  
즉, 탐색 시 서버에 새로운 요청을 하는 대신 캐시가 최대한 재사용됨으로써 전송되는 요청 및 데이터의 수를 줄여 성능을 개선할 수 있다.  
라우터 캐시의 작동 방식과 구성 방법에 대해 자세히 알아보자.

### 3. 부분 렌더링

부분 렌더링은 클라이언트에서 탐색 재렌더링 시 변경되는 경로 세그먼트만을 의미하며, 공유된 세그먼트는 모두 보존된다.  
예를 들어 두 형제 경로, /dashboard/settings 및 /dashboard/analytics 간을 탐색할 때, 설정 및 분석 페이지가 렌더되고 공유된 dashboard layout이 유지된다.  
부분 렌더링을 하지 않으면 각 탐색을 통해 전체 페이지가 서버에 다시 렌더된다. 변경되는 세그먼트만 렌더링하면 전송되는 데이터의 양과 실행 시간이 줄어 성능이 향상된다.

### 4. Soft Navigation

기본적으로 브라우저는 페이지 간에 하드 탐색한다. 즉, 브라우저는 페이지를 리로드하고 앱의 useState hook과 같은 React 상태와 사용자의 스크롤 위치 또는 포커스된 요소와 같은 브라우저 상태를 재설정한다.  
그러나 Next.js에서 앱 라우터는 소프트 탐색을 사용한다. 즉, React는 React와 브라우저 상태를 유지하면서 변경된 세그먼트만 렌더링하고 전체 페이지 재로드는 없다.

### 5. 앞뒤로 탐색

기본적으로 Next.js는 앞뒤 탐색을 위해 스크롤 위치를 유지하고 라우터 캐시에서 경로 세그먼트를 다시 사용한다.
